import { Scalar, ValidatedSelector } from "../simple"
import { CompleteSelector } from "./complete-selector"

type function Selected = (S, T) => ^{
  if (T extends Scalar) {
    return T
  } else if (T extends Array<infer U>) {
    return Array<SelectionResult<S, U>>
  } else if (T extends type (args: infer A) => infer R) {
    return ^{
      if (S extends [A, infer SR]) { /* TODO I think the issue is here, but need more test cases */
        return SelectionResult<SR, R>
      } else {
        return never /* unreachable: S is a selector for T by construction in SelectionResult */
      }
    }
  } else {
    return SelectionResult<S, T>
  }
}

export type function SelectionResult = (S, T) => ^{
  if (CompleteSelector<T> extends S) {
    return ^{
      for (Key in keyof S) {
        return {
          key: Key,
          value: ^{
            if (Key extends keyof T) {
              return Selected<S[Key], T[Key]>
            } else {
              return "keys of S are keys of T, so this case is impossible but hard to prove"
            }
          }
        }
      }
    }
  } else {
    return "invalid selector. S is not a selector for T."
  }
}

/* defined here to avoid circular imports */
export type function Selector = (S, T) => ^{
	if (CompleteSelector<T> extends S) {
		return & [
			S,
			ValidatedSelector<SelectionResult<S, T>>
		]
	} else {
		return "invalid selector. S is not a selector for T."
	}
}